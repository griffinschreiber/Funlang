#ifndef LEXER_H_
#define LEXER_H_

enum token_type {
  LEX_EOF,
  LEX_SEMICOLON,

  LEX_ASSIGNMENT,

  LEX_IDENTIFIER,

  LEX_NUM_LITERAL,
  LEX_HEX_LITERAL,
  LEX_BINARY_LITERAL,
  LEX_OCTAL_LITERAL,
  LEX_CHAR_LITERAL,
  LEX_STR_LITERAL,

  LEX_PLUS,
  LEX_MINUS,
  LEX_STAR,
  LEX_SLASH,

  LEX_INCREMENT,
  LEX_DECREMENT,

  LEX_MOD,

  LEX_PLUS_EQUALS,
  LEX_MINUS_EQUALS,
  LEX_STAR_EQUALS,
  LEX_SLASH_EQUALS,
  LEX_MOD_EQUALS,
  LEX_BITWISE_AND_EQUALS,
  LEX_BITWISE_OR_EQUALS,
  LEX_BITWISE_XOR_EQUALS,
  LEX_BITWISE_NOT_EQUALS,
  LEX_LSHIFT_EQUALS,
  LEX_RSHIFT_EQUALS,

  LEX_EQUALS,
  LEX_NOT_EQUALS,
  LEX_LESS_THAN,
  LEX_GREATER_THAN,
  LEX_LESS_THAN_OR_EQUAL_TO,
  LEX_GREATER_THAN_OR_EQUAL_TO,

  LEX_AND,
  LEX_OR,
  LEX_NOT,

  LEX_BITWISE_AND,
  LEX_BITWISE_OR,
  LEX_BITWISE_XOR,
  LEX_BITWISE_NOT,
  LEX_LSHIFT,
  LEX_RSHIFT,

  LEX_VOID,

  LEX_BOOL,
  LEX_CHAR,
  LEX_UCHAR,
  LEX_SHORT,
  LEX_USHORT,
  LEX_INT,
  LEX_UINT,
  LEX_LONG,
  LEX_ULONG,
  LEX_FLOAT,
  LEX_UFLOAT,
  LEX_DOUBLE,
  LEX_UDOUBLE,

  LEX_CONST,

  LEX_DIE,

  LEX_RETURN,

  LEX_TYPEDEF,
  LEX_STRUCT,
  LEX_ENUM,
  LEX_UNION,

  LEX_IF,
  LEX_ELSE,
  LEX_SWITCH,
  LEX_CASE,
  LEX_FOR,
  LEX_WHILE,

  LEX_LPARENS,
  LEX_RPARENS,
  LEX_LBRACKETS,
  LEX_RBRACKETS,
  LEX_LCURLY_BRACE,
  LEX_RCURLY_BRACE
};

struct token {
  char *start;
  int len;
  enum token_type type;
  int line;
};

struct lexer {
  char *start;
  char *current;
  int line;
};

struct token lex(struct lexer *lexer);

#endif // LEXER_H_
